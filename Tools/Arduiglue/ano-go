#!/usr/bin/env tclsh

# Update/rewrite of my ino-go front-end for ino/inotool, to now work with ano/Arturo, and to remove dependency on Zenity.
# Requires: Tcl/Tk, Arturo.
# Want compatibility with Linux, Mac OS, Windows.
# Imagine using with Geany, TextWrangler, Sublime Text, as well as plain command-line use.


# TODO: copy across some code from existing ino-go program.


# Platform detection stuff:
switch $tcl_platform(os) {
	Darwin {
		interp alias {} scan_for_devices {} scan_for_devices_Mac
	}
	Linux {
		interp alias {} scan_for_devices {} scan_for_devices_Linux
	}
	"Windows NT" {
		package require registry
		interp alias {} scan_for_devices {} scan_for_devices_Windows
	}
	default {
		puts stderr "Unrecognised platform: $tcl_platform(os).\nExiting."
		exit
	}
}

# OS-specific procedures for identifying potential Arduino devices that are attached to the system:

# Original Linux-specific technique from my first implementation:
# Uses the nice system-generated by-id paths from /dev, which generally contain a substring based on the USB device's reported vendor and product names.
# Note the side-effects here: it copies data into the arrays (found_usb_id, found_ino_model, found_model) as well as returning a list of canonical device special file names.

proc scan_for_devices_Linux {} {
	global known_devices dev_substring ino_model model_label
	global found_usb_id found_ino_model found_model_label
	set candidate_devices [list]
	foreach device [glob -nocomplain /dev/serial/by-id/*] {
		foreach id $known_devices {
			if {[string match *$dev_substring($id)* $device]} {
				set dev [file normalize /dev/serial/by-id/[file readlink $device]]
				set found_usb_id($dev) $id
				set found_ino_model($dev) $ino_model($id)
				set found_model_label($dev) $model_label($id)
				lappend candidate_devices $dev
			}
		}
	}
	return $candidate_devices
}



# On the Mac, we don't have such a nice /dev tree, or /proc, or /sys, nor is lsusb available.
# Instead, there is an ioreg command that can enumerate USB devices, although the output isn't pretty (either the default text-based tree or the XML "archive" format).

# Also, can ioreg be used to determine which /dev special file corresponds to the given USB vendor/product ID?  On Linux we could simply find where the /dev/serial/by-id symlink pointed.
proc scan_for_devices_Mac {} {
	puts stderr "Sorry, device search on Mac OS not implemented yet."
}

# On Windows, serial devices are named COM1, COM3, etc.  How to enumerate?  And how to relate to USB device IDs?  One way is to use the Registry:

# TODO: put platform detection code all in one place, at the start maybe?  And automatically alias platform-specific procs?
#package require registry
 
proc get_serial_ports { } {
	set serial_base "HKEY_LOCAL_MACHINE\\HARDWARE\\DEVICEMAP\\SERIALCOMM"
	set values [ registry values $serial_base ]
 
	set result {}
 
	foreach valueName $values {
		lappend result [ registry get $serial_base $valueName ]
	}
 
	return $result
}

# Oren Trutner on stackoverflow suggests:
# 1. Call QueryDosDevice with a NULL lpDeviceName to list all DOS devices. Then use CreateFile and GetCommConfig with each device name in turn to figure out whether it's a serial port.
# 2. Call SetupDiGetClassDevs with a ClassGuid of GUID_DEVINTERFACE_COMPORT.
# 3. WMI is also available to C/C++ programs.

proc scan_for_devices_Windows {} {
	puts stderr "Sorry, device search on Windows not implemented yet."
}



# TODO: Zenity replacement code for GUI selection of device here...


puts "Scanning for candidate Arduino devices:"
puts [scan_for_devices]

# TODO: call ano to build and upload...
